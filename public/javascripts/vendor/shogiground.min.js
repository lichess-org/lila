var Shogiground = (function () {
  "use strict";
  function e(e, t, o) {
    return (
      e(
        (o = {
          path: t,
          exports: {},
          require: function (e, t) {
            return (function () {
              throw new Error(
                "Dynamic requires are not currently supported by @rollup/plugin-commonjs"
              );
            })(null == t && o.path);
          },
        }),
        o.exports
      ),
      o.exports
    );
  }
  var t = e(function (e, t) {
      Object.defineProperty(t, "__esModule", { value: !0 }),
        (t.ranks = t.files = t.colors = void 0),
        (t.colors = ["white", "black"]),
        (t.files = ["a", "b", "c", "d", "e", "f", "g", "h", "i"]),
        (t.ranks = ["1", "2", "3", "4", "5", "6", "7", "8", "9"]);
    }),
    o = e(function (e, o) {
      Object.defineProperty(o, "__esModule", { value: !0 }),
        (o.createEl = o.isRightButton = o.eventPosition = o.setVisible = o.translateRel = o.translateAbs = o.posToTranslateRel = o.posToTranslateAbs = o.samePiece = o.distanceSq = o.opposite = o.timer = o.memo = o.key2pos = o.pos2key = o.allKeys = o.invRanks = void 0),
        (o.invRanks = ["9", "8", "7", "6", "5", "4", "3", "2", "1"]),
        (o.allKeys = Array.prototype.concat(
          ...t.files.map((e) => t.ranks.map((t) => e + t))
        )),
        (o.pos2key = (e) => o.allKeys[9 * e[0] + e[1]]),
        (o.key2pos = (e) => [e.charCodeAt(0) - 97, e.charCodeAt(1) - 49]),
        (o.memo = function (e) {
          let t;
          const o = () => (void 0 === t && (t = e()), t);
          return (
            (o.clear = () => {
              t = void 0;
            }),
            o
          );
        }),
        (o.timer = () => {
          let e;
          return {
            start() {
              e = performance.now();
            },
            cancel() {
              e = void 0;
            },
            stop() {
              if (!e) return 0;
              const t = performance.now() - e;
              return (e = void 0), t;
            },
          };
        }),
        (o.opposite = (e) => ("white" === e ? "black" : "white")),
        (o.distanceSq = (e, t) => {
          const o = e[0] - t[0],
            n = e[1] - t[1];
          return o * o + n * n;
        }),
        (o.samePiece = (e, t) => e.role === t.role && e.color === t.color);
      const n = (e, t, o, n) => [
        (t ? e[0] : 8 - e[0]) * o,
        (t ? 8 - e[1] : e[1]) * n,
      ];
      (o.posToTranslateAbs = (e) => {
        const t = e.width / 9,
          o = e.height / 9;
        return (e, r) => n(e, r, t, o);
      }),
        (o.posToTranslateRel = (e, t) => n(e, t, 100, 100)),
        (o.translateAbs = (e, t) => {
          e.style.transform = `translate(${t[0]}px,${t[1]}px)`;
        }),
        (o.translateRel = (e, t) => {
          e.style.transform = `translate(${t[0]}%,${t[1]}%)`;
        }),
        (o.setVisible = (e, t) => {
          e.style.visibility = t ? "visible" : "hidden";
        }),
        (o.eventPosition = (e) =>
          e.clientX || 0 === e.clientX
            ? [e.clientX, e.clientY]
            : e.touches && e.targetTouches[0]
            ? [e.targetTouches[0].clientX, e.targetTouches[0].clientY]
            : void 0),
        (o.isRightButton = (e) => 2 === e.buttons || 2 === e.button),
        (o.createEl = (e, t) => {
          const o = document.createElement(e);
          return t && (o.className = t), o;
        });
    }),
    n = e(function (e, t) {
      function n(e, t) {
        return Math.abs(e - t);
      }
      Object.defineProperty(t, "__esModule", { value: !0 }),
        (t.premove = void 0);
      const r = (e, t, o, r) => n(e, o) === n(t, r),
        s = (e, t, o, n) => e === o || t === n,
        i = (e, t, o, r) => n(e, o) < 2 && n(t, r) < 2;
      const a = (e, t, o, n) => i(e, t, o, n) || r(e, t, o, n),
        c = (e, t, o, n) => i(e, t, o, n) || s(e, t, o, n),
        l = o.allKeys.map(o.key2pos);
      t.premove = function (e, t) {
        const d = e.get(t);
        if (!d) return [];
        const u = o.key2pos(t),
          p = d.role,
          f =
            "pawn" === p
              ? ((g = d.color),
                (e, t, o, n) =>
                  "white" === g
                    ? e === o && t + 1 === n
                    : e === o && t - 1 === n)
              : "knight" === p
              ? (function (e) {
                  return (t, o, r, s) =>
                    1 === n(t, r) &&
                    2 === n(o, s) &&
                    ("white" === e ? s > o : s < o);
                })(d.color)
              : "bishop" === p
              ? r
              : "rook" === p
              ? s
              : "king" === p
              ? i
              : "silver" === p
              ? (function (e) {
                  return (t, o, r, s) =>
                    n(t, r) < 2 &&
                    n(o, s) < 2 &&
                    o != s &&
                    ("white" === e ? t != r || s > o : t != r || s < o);
                })(d.color)
              : "lance" === p
              ? (function (e) {
                  return (t, o, n, r) =>
                    t == n && "white" === e ? r > o : o > r;
                })(d.color)
              : "horse" === p
              ? a
              : "dragon" === p
              ? c
              : (function (e) {
                  return (t, o, r, s) =>
                    n(t, r) < 2 &&
                    n(o, s) < 2 &&
                    ("white" === e ? s >= o || t == r : s <= o || t == r);
                })(d.color);
        var g;
        return l
          .filter(
            (e) => (u[0] !== e[0] || u[1] !== e[1]) && f(u[0], u[1], e[0], e[1])
          )
          .map(o.pos2key);
      };
    }),
    r = e(function (e, t) {
      function r(e, ...t) {
        e && setTimeout(() => e(...t), 1);
      }
      function s(e) {
        e.premovable.current &&
          ((e.premovable.current = void 0), r(e.premovable.events.unset));
      }
      function i(e) {
        const t = e.predroppable;
        t.current && ((t.current = void 0), r(t.events.unset));
      }
      function a(e, t, n) {
        const s = e.pieces.get(t),
          i = e.pieces.get(n);
        if (t === n || !s) return !1;
        const a = i && i.color !== s.color ? i : void 0;
        return (
          n === e.selected && p(e),
          r(e.events.move, t, n, a),
          (function (e, t, n) {
            if (!e.autoCastle) return !1;
            const r = e.pieces.get(t);
            if (!r || "king" !== r.role) return !1;
            const s = o.key2pos(t),
              i = o.key2pos(n);
            if ((0 !== s[1] && 7 !== s[1]) || s[1] !== i[1]) return !1;
            4 !== s[0] ||
              e.pieces.has(n) ||
              (6 === i[0]
                ? (n = o.pos2key([7, i[1]]))
                : 2 === i[0] && (n = o.pos2key([0, i[1]])));
            const a = e.pieces.get(n);
            return (
              !(!a || a.color !== r.color || "rook" !== a.role) &&
              (e.pieces.delete(t),
              e.pieces.delete(n),
              s[0] < i[0]
                ? (e.pieces.set(o.pos2key([6, i[1]]), r),
                  e.pieces.set(o.pos2key([5, i[1]]), a))
                : (e.pieces.set(o.pos2key([2, i[1]]), r),
                  e.pieces.set(o.pos2key([3, i[1]]), a)),
              !0)
            );
          })(e, t, n) || (e.pieces.set(n, s), e.pieces.delete(t)),
          (e.lastMove = [t, n]),
          (e.check = void 0),
          r(e.events.change),
          a || !0
        );
      }
      function c(e, t, n, s) {
        if (e.pieces.has(n)) {
          if (!s) return !1;
          e.pieces.delete(n);
        }
        return (
          r(e.events.dropNewPiece, t, n),
          e.pieces.set(n, t),
          (e.lastMove = [n]),
          (e.check = void 0),
          r(e.events.change),
          (e.movable.dests = void 0),
          (e.turnColor = o.opposite(e.turnColor)),
          !0
        );
      }
      function l(e, t, n) {
        const r = a(e, t, n);
        return (
          r &&
            ((e.movable.dests = void 0),
            (e.turnColor = o.opposite(e.turnColor)),
            (e.animation.current = void 0)),
          r
        );
      }
      function d(e, t, o) {
        if (g(e, t, o)) {
          const n = l(e, t, o);
          if (n) {
            const s = e.hold.stop();
            p(e);
            const i = { premove: !1, ctrlKey: e.stats.ctrlKey, holdTime: s };
            return (
              !0 !== n && (i.captured = n),
              r(e.movable.events.after, t, o, i),
              !0
            );
          }
        } else if (
          (function (e, t, o) {
            return t !== o && v(e, t) && n.premove(e.pieces, t).includes(o);
          })(e, t, o)
        )
          return (
            (function (e, t, o, n) {
              i(e),
                (e.premovable.current = [t, o]),
                r(e.premovable.events.set, t, o, n);
            })(e, t, o, { ctrlKey: e.stats.ctrlKey }),
            p(e),
            !0
          );
        return p(e), !1;
      }
      function u(e, t) {
        (e.selected = t),
          v(e, t)
            ? (e.premovable.dests = n.premove(e.pieces, t))
            : (e.premovable.dests = void 0);
      }
      function p(e) {
        (e.selected = void 0), (e.premovable.dests = void 0), e.hold.cancel();
      }
      function f(e, t) {
        const o = e.pieces.get(t);
        return (
          !!o &&
          ("both" === e.movable.color ||
            (e.movable.color === o.color && e.turnColor === o.color))
        );
      }
      function g(e, t, o) {
        var n, r;
        return (
          t !== o &&
          f(e, t) &&
          (e.movable.free ||
            !!(null ===
              (r =
                null === (n = e.movable.dests) || void 0 === n
                  ? void 0
                  : n.get(t)) || void 0 === r
              ? void 0
              : r.includes(o)))
        );
      }
      function v(e, t) {
        const o = e.pieces.get(t);
        return (
          !!o &&
          e.premovable.enabled &&
          e.movable.color === o.color &&
          e.turnColor !== o.color
        );
      }
      function h(e) {
        s(e), i(e), p(e);
      }
      Object.defineProperty(t, "__esModule", { value: !0 }),
        (t.whitePov = t.getKeyAtDomPos = t.stop = t.cancelMove = t.playPredrop = t.playPremove = t.isDraggable = t.canMove = t.unselect = t.setSelected = t.selectSquare = t.dropNewPiece = t.userMove = t.baseNewPiece = t.baseMove = t.unsetPredrop = t.unsetPremove = t.setCheck = t.setPieces = t.reset = t.toggleOrientation = t.callUserFunction = void 0),
        (t.callUserFunction = r),
        (t.toggleOrientation = function (e) {
          (e.orientation = o.opposite(e.orientation)),
            (e.animation.current = e.draggable.current = e.selected = void 0);
        }),
        (t.reset = function (e) {
          (e.lastMove = void 0), p(e), s(e), i(e);
        }),
        (t.setPieces = function (e, t) {
          for (const [o, n] of t) n ? e.pieces.set(o, n) : e.pieces.delete(o);
        }),
        (t.setCheck = function (e, t) {
          if (((e.check = void 0), !0 === t && (t = e.turnColor), t))
            for (const [o, n] of e.pieces)
              "king" === n.role && n.color === t && (e.check = o);
        }),
        (t.unsetPremove = s),
        (t.unsetPredrop = i),
        (t.baseMove = a),
        (t.baseNewPiece = c),
        (t.userMove = d),
        (t.dropNewPiece = function (e, t, o, n) {
          const a = e.pieces.get(t);
          a &&
          ((function (e, t, o) {
            const n = e.pieces.get(t);
            return !(
              !n ||
              (t !== o && e.pieces.has(o)) ||
              ("both" !== e.movable.color &&
                (e.movable.color !== n.color || e.turnColor !== n.color))
            );
          })(e, t, o) ||
            n)
            ? (e.pieces.delete(t),
              c(e, a, o, n),
              r(e.movable.events.afterNewPiece, a.role, o, { predrop: !1 }))
            : a &&
              (function (e, t, o) {
                const n = e.pieces.get(t),
                  r = e.pieces.get(o);
                return (
                  !!n &&
                  (!r || r.color !== e.movable.color) &&
                  e.predroppable.enabled &&
                  e.movable.color === n.color &&
                  e.turnColor !== n.color
                );
              })(e, t, o)
            ? (function (e, t, o) {
                s(e),
                  (e.predroppable.current = { role: t, key: o }),
                  r(e.predroppable.events.set, t, o);
              })(e, a.role, o)
            : (s(e), i(e)),
            e.pieces.delete(t),
            p(e);
        }),
        (t.selectSquare = function (e, t, o) {
          if ((r(e.events.select, t), e.selected)) {
            if (e.selected === t && !e.draggable.enabled)
              return p(e), void e.hold.cancel();
            if (
              (e.selectable.enabled || o) &&
              e.selected !== t &&
              d(e, e.selected, t)
            )
              return void (e.stats.dragged = !1);
          }
          (f(e, t) || v(e, t)) && (u(e, t), e.hold.start());
        }),
        (t.setSelected = u),
        (t.unselect = p),
        (t.canMove = g),
        (t.isDraggable = function (e, t) {
          const o = e.pieces.get(t);
          return (
            !!o &&
            e.draggable.enabled &&
            ("both" === e.movable.color ||
              (e.movable.color === o.color &&
                (e.turnColor === o.color || e.premovable.enabled)))
          );
        }),
        (t.playPremove = function (e) {
          const t = e.premovable.current;
          if (!t) return !1;
          const o = t[0],
            n = t[1];
          let i = !1;
          if (g(e, o, n)) {
            const t = l(e, o, n);
            if (t) {
              const s = { premove: !0 };
              !0 !== t && (s.captured = t),
                r(e.movable.events.after, o, n, s),
                (i = !0);
            }
          }
          return s(e), i;
        }),
        (t.playPredrop = function (e, t) {
          const o = e.predroppable.current;
          let n = !1;
          if (!o) return !1;
          if (t(o)) {
            c(e, { role: o.role, color: e.movable.color }, o.key) &&
              (r(e.movable.events.afterNewPiece, o.role, o.key, {
                predrop: !0,
              }),
              (n = !0));
          }
          return i(e), n;
        }),
        (t.cancelMove = h),
        (t.stop = function (e) {
          (e.movable.color = e.movable.dests = e.animation.current = void 0),
            h(e);
        }),
        (t.getKeyAtDomPos = function (e, t, n) {
          let r = Math.floor((9 * (e[0] - n.left)) / n.width);
          t || (r = 8 - r);
          let s = 8 - Math.floor((9 * (e[1] - n.top)) / n.height);
          return (
            t || (s = 8 - s),
            r >= 0 && r < 9 && s >= 0 && s < 9 ? o.pos2key([r, s]) : void 0
          );
        }),
        (t.whitePov = function (e) {
          return "white" === e.orientation;
        });
    }),
    s = e(function (e, n) {
      Object.defineProperty(n, "__esModule", { value: !0 }),
        (n.write = n.read = n.initial = void 0),
        (n.initial =
          "lnsgkgsnl/1r5b1/ppppppppp/9/9/9/PPPPPPPPP/1B5R1/LNSGKGSNL");
      const r = {
          p: "pawn",
          l: "lance",
          n: "knight",
          s: "silver",
          g: "gold",
          b: "bishop",
          r: "rook",
          k: "king",
          "+p": "tokin",
          t: "tokin",
          "+l": "promotedLance",
          u: "promotedLance",
          "+n": "promotedKnight",
          m: "promotedKnight",
          "+s": "promotedSilver",
          a: "promotedSilver",
          "+b": "horse",
          h: "horse",
          "+r": "dragon",
          d: "dragon",
        },
        s = {
          pawn: "p",
          lance: "l",
          knight: "n",
          silver: "s",
          gold: "g",
          bishop: "b",
          rook: "r",
          king: "k",
          tokin: "t",
          promotedLance: "u",
          promotedKnight: "m",
          promotedSilver: "a",
          horse: "h",
          dragon: "d",
        };
      (n.read = function (e) {
        "start" === e && (e = n.initial);
        const t = new Map();
        let s = 8,
          i = 0;
        for (let n = 0; n < e.length; n++)
          switch (e[n]) {
            case "_":
            case " ":
              return t;
            case "/":
              if ((--s, s < 0)) return t;
              i = 0;
              break;
            case "~":
              const a = t.get(o.pos2key([i, s]));
              a && (a.promoted = !0);
              break;
            default:
              const c = e[n].charCodeAt(0);
              if (c < 58 && 43 != c) i += c - 48;
              else {
                const a =
                    "+" === e[n] && e.length > n + 1
                      ? "+" + e[++n].toLowerCase()
                      : e[n].toLowerCase(),
                  c = e[n] === a || "+" + e[n] === a ? "black" : "white";
                t.set(o.pos2key([i, s]), { role: r[a], color: c }), ++i;
              }
          }
        return t;
      }),
        (n.write = function (e) {
          return o.invRanks
            .map((o) =>
              t.files
                .map((t) => {
                  const n = e.get(t + o);
                  if (n) {
                    const e = s[n.role];
                    return "white" === n.color ? e.toUpperCase() : e;
                  }
                  return "1";
                })
                .join("")
            )
            .join("/")
            .replace(/1{2,}/g, (e) => e.length.toString());
        });
    }),
    i = e(function (e, t) {
      function o(e) {
        return "object" == typeof e;
      }
      Object.defineProperty(t, "__esModule", { value: !0 }),
        (t.configure = void 0),
        (t.configure = function (e, t) {
          var n;
          if (
            ((null === (n = t.movable) || void 0 === n ? void 0 : n.dests) &&
              (e.movable.dests = void 0),
            (function e(t, n) {
              for (const r in n)
                o(t[r]) && o(n[r]) ? e(t[r], n[r]) : (t[r] = n[r]);
            })(e, t),
            t.fen && ((e.pieces = s.read(t.fen)), (e.drawable.shapes = [])),
            t.hasOwnProperty("check") && r.setCheck(e, t.check || !1),
            t.hasOwnProperty("lastMove") && !t.lastMove
              ? (e.lastMove = void 0)
              : t.lastMove && (e.lastMove = t.lastMove),
            e.selected && r.setSelected(e, e.selected),
            (!e.animation.duration || e.animation.duration < 100) &&
              (e.animation.enabled = !1),
            !e.movable.rookCastle && e.movable.dests)
          ) {
            const t = "white" === e.movable.color ? "1" : "9",
              o = "e" + t,
              n = e.movable.dests.get(o),
              r = e.pieces.get(o);
            if (!n || !r || "king" !== r.role) return;
            e.movable.dests.set(
              o,
              n.filter(
                (e) =>
                  !(
                    (e === "a" + t && n.includes("c" + t)) ||
                    (e === "h" + t && n.includes("g" + t))
                  )
              )
            );
          }
        });
    }),
    a = e(function (e, t) {
      function n(e, t) {
        const o = e(t);
        return t.dom.redraw(), o;
      }
      function r(e, t) {
        return { key: e, pos: o.key2pos(e), piece: t };
      }
      function s(e, t) {
        return t.sort(
          (t, n) => o.distanceSq(e.pos, t.pos) - o.distanceSq(e.pos, n.pos)
        )[0];
      }
      Object.defineProperty(t, "__esModule", { value: !0 }),
        (t.render = t.anim = void 0),
        (t.anim = function (e, t) {
          return t.animation.enabled
            ? (function (e, t) {
                const n = new Map(t.pieces),
                  i = e(t),
                  a = (function (e, t) {
                    const n = new Map(),
                      i = [],
                      a = new Map(),
                      c = [],
                      l = [],
                      d = new Map();
                    let u, p, f;
                    for (const [o, s] of e) d.set(o, r(o, s));
                    for (const s of o.allKeys)
                      (u = t.pieces.get(s)),
                        (p = d.get(s)),
                        u
                          ? p
                            ? o.samePiece(u, p.piece) ||
                              (c.push(p), l.push(r(s, u)))
                            : l.push(r(s, u))
                          : p && c.push(p);
                    for (const r of l)
                      (p = s(
                        r,
                        c.filter((e) => o.samePiece(r.piece, e.piece))
                      )),
                        p &&
                          ((f = [p.pos[0] - r.pos[0], p.pos[1] - r.pos[1]]),
                          n.set(r.key, f.concat(f)),
                          i.push(p.key));
                    for (const o of c)
                      i.includes(o.key) || a.set(o.key, o.piece);
                    return { anims: n, fadings: a };
                  })(n, t);
                if (a.anims.size || a.fadings.size) {
                  const e = t.animation.current && t.animation.current.start;
                  (t.animation.current = {
                    start: performance.now(),
                    frequency: 1 / t.animation.duration,
                    plan: a,
                  }),
                    e ||
                      (function e(t, o) {
                        const n = t.animation.current;
                        if (void 0 === n)
                          return void (t.dom.destroyed || t.dom.redrawNow());
                        const r = 1 - (o - n.start) * n.frequency;
                        if (r <= 0)
                          (t.animation.current = void 0), t.dom.redrawNow();
                        else {
                          const o =
                            (s = r) < 0.5
                              ? 4 * s * s * s
                              : (s - 1) * (2 * s - 2) * (2 * s - 2) + 1;
                          for (const e of n.plan.anims.values())
                            (e[2] = e[0] * o), (e[3] = e[1] * o);
                          t.dom.redrawNow(!0),
                            requestAnimationFrame((o = performance.now()) =>
                              e(t, o)
                            );
                        }
                        var s;
                      })(t, performance.now());
                } else t.dom.redraw();
                return i;
              })(e, t)
            : n(e, t);
        }),
        (t.render = n);
    }),
    c = e(function (e, t) {
      Object.defineProperty(t, "__esModule", { value: !0 }),
        (t.clear = t.cancel = t.end = t.move = t.processDraw = t.start = void 0);
      const n = ["green", "red", "blue", "yellow"];
      function s(e) {
        requestAnimationFrame(() => {
          const t = e.drawable.current;
          if (t) {
            const o = r.getKeyAtDomPos(t.pos, r.whitePov(e), e.dom.bounds());
            o !== t.mouseSq &&
              ((t.mouseSq = o),
              (t.dest = o !== t.orig ? o : void 0),
              e.dom.redrawNow()),
              s(e);
          }
        });
      }
      function i(e) {
        e.drawable.current && ((e.drawable.current = void 0), e.dom.redraw());
      }
      function a(e) {
        const t = (e.shiftKey || e.ctrlKey) && o.isRightButton(e),
          r = e.altKey || e.metaKey || e.getModifierState("AltGraph");
        return n[(t ? 1 : 0) + (r ? 2 : 0)];
      }
      function c(e) {
        e.onChange && e.onChange(e.shapes);
      }
      (t.start = function (e, t) {
        if (t.touches && t.touches.length > 1) return;
        t.stopPropagation(),
          t.preventDefault(),
          t.ctrlKey ? r.unselect(e) : r.cancelMove(e);
        const n = o.eventPosition(t),
          i = r.getKeyAtDomPos(n, r.whitePov(e), e.dom.bounds());
        i && ((e.drawable.current = { orig: i, pos: n, brush: a(t) }), s(e));
      }),
        (t.processDraw = s),
        (t.move = function (e, t) {
          e.drawable.current && (e.drawable.current.pos = o.eventPosition(t));
        }),
        (t.end = function (e) {
          const t = e.drawable.current;
          t &&
            (t.mouseSq &&
              (function (e, t) {
                const o = (e) => e.orig === t.orig && e.dest === t.dest,
                  n = e.shapes.find(o);
                n && (e.shapes = e.shapes.filter((e) => !o(e)));
                (n && n.brush === t.brush) || e.shapes.push(t);
                c(e);
              })(e.drawable, t),
            i(e));
        }),
        (t.cancel = i),
        (t.clear = function (e) {
          e.drawable.shapes.length &&
            ((e.drawable.shapes = []), e.dom.redraw(), c(e.drawable));
        });
    }),
    l = e(function (e, t) {
      function n(e) {
        requestAnimationFrame(() => {
          var t;
          const r = e.draggable.current;
          if (!r) return;
          (null === (t = e.animation.current) || void 0 === t
            ? void 0
            : t.plan.anims.has(r.orig)) && (e.animation.current = void 0);
          const i = e.pieces.get(r.orig);
          if (i && o.samePiece(i, r.piece)) {
            if (
              (!r.started &&
                o.distanceSq(r.pos, r.origPos) >=
                  Math.pow(e.draggable.distance, 2) &&
                (r.started = !0),
              r.started)
            ) {
              if ("function" == typeof r.element) {
                const e = r.element();
                if (!e) return;
                (e.cgDragging = !0),
                  e.classList.add("dragging"),
                  (r.element = e);
              }
              const t = e.dom.bounds();
              o.translateAbs(r.element, [
                r.pos[0] - t.left - t.width / 18,
                r.pos[1] - t.top - t.height / 18,
              ]);
            }
          } else s(e);
          n(e);
        });
      }
      function s(e) {
        const t = e.draggable.current;
        t &&
          (t.newPiece && e.pieces.delete(t.orig),
          (e.draggable.current = void 0),
          r.unselect(e),
          i(e),
          e.dom.redraw());
      }
      function i(e) {
        const t = e.dom.elements;
        t.ghost && o.setVisible(t.ghost, !1);
      }
      function l(e, t, n) {
        const r = o.key2pos(e);
        return (
          t || ((r[0] = 8 - r[0]), (r[1] = 8 - r[1])),
          [
            n.left + (n.width * r[0]) / 9 + n.width / 18,
            n.top + (n.height * (8 - r[1])) / 9 + n.height / 18,
          ]
        );
      }
      function d(e, t) {
        let o = e.dom.elements.board.firstChild;
        for (; o; ) {
          if (o.cgKey === t && "PIECE" === o.tagName) return o;
          o = o.nextSibling;
        }
      }
      Object.defineProperty(t, "__esModule", { value: !0 }),
        (t.cancel = t.end = t.move = t.dragNewPiece = t.start = void 0),
        (t.start = function (e, t) {
          if (void 0 !== t.button && 0 !== t.button) return;
          if (t.touches && t.touches.length > 1) return;
          const s = e.dom.bounds(),
            i = o.eventPosition(t),
            u = r.getKeyAtDomPos(i, r.whitePov(e), s);
          if (!u) return;
          const p = e.pieces.get(u),
            f = e.selected;
          f ||
            !e.drawable.enabled ||
            (!e.drawable.eraseOnClick && p && p.color === e.turnColor) ||
            c.clear(e),
            !1 === t.cancelable ||
              (t.touches &&
                e.movable.color &&
                !p &&
                !f &&
                !(function (e, t) {
                  const n = r.whitePov(e),
                    s = e.dom.bounds(),
                    i = Math.pow(s.width / 9, 2);
                  for (const r in e.pieces) {
                    const e = l(r, n, s);
                    if (o.distanceSq(e, t) <= i) return !0;
                  }
                  return !1;
                })(e, i)) ||
              t.preventDefault();
          const g = !!e.premovable.current,
            v = !!e.predroppable.current;
          (e.stats.ctrlKey = t.ctrlKey),
            e.selected && r.canMove(e, e.selected, u)
              ? a.anim((e) => r.selectSquare(e, u), e)
              : r.selectSquare(e, u);
          const h = e.selected === u,
            m = d(e, u);
          if (p && m && h && r.isDraggable(e, u)) {
            (e.draggable.current = {
              orig: u,
              piece: p,
              origPos: i,
              pos: i,
              started: e.draggable.autoDistance && e.stats.dragged,
              element: m,
              previouslySelected: f,
              originTarget: t.target,
            }),
              (m.cgDragging = !0),
              m.classList.add("dragging");
            const a = e.dom.elements.ghost;
            a &&
              ((a.className = `ghost ${p.color} ${p.role}`),
              o.translateAbs(
                a,
                o.posToTranslateAbs(s)(o.key2pos(u), r.whitePov(e))
              ),
              o.setVisible(a, !0)),
              n(e);
          } else g && r.unsetPremove(e), v && r.unsetPredrop(e);
          e.dom.redraw();
        }),
        (t.dragNewPiece = function (e, t, r, s) {
          e.pieces.set("a0", t), e.dom.redraw();
          const i = o.eventPosition(r);
          (e.draggable.current = {
            orig: "a0",
            piece: t,
            origPos: i,
            pos: i,
            started: !0,
            element: () => d(e, "a0"),
            originTarget: r.target,
            newPiece: !0,
            force: !!s,
          }),
            n(e);
        }),
        (t.move = function (e, t) {
          e.draggable.current &&
            (!t.touches || t.touches.length < 2) &&
            (e.draggable.current.pos = o.eventPosition(t));
        }),
        (t.end = function (e, t) {
          const n = e.draggable.current;
          if (!n) return;
          if (
            ("touchend" === t.type && !1 !== t.cancelable && t.preventDefault(),
            "touchend" === t.type && n.originTarget !== t.target && !n.newPiece)
          )
            return void (e.draggable.current = void 0);
          r.unsetPremove(e), r.unsetPredrop(e);
          const s = o.eventPosition(t) || n.pos,
            a = r.getKeyAtDomPos(s, r.whitePov(e), e.dom.bounds());
          a && n.started && n.orig !== a
            ? n.newPiece
              ? r.dropNewPiece(e, n.orig, a, n.force)
              : ((e.stats.ctrlKey = t.ctrlKey),
                r.userMove(e, n.orig, a) && (e.stats.dragged = !0))
            : n.newPiece
            ? e.pieces.delete(n.orig)
            : e.draggable.deleteOnDropOff &&
              !a &&
              (e.pieces.delete(n.orig), r.callUserFunction(e.events.change)),
            ((n.orig !== n.previouslySelected || (n.orig !== a && a)) &&
              e.selectable.enabled) ||
              r.unselect(e),
            i(e),
            (e.draggable.current = void 0),
            e.dom.redraw();
        }),
        (t.cancel = s);
    }),
    d = e(function (e, t) {
      Object.defineProperty(t, "__esModule", { value: !0 }),
        (t.start = void 0),
        (t.start = function (e, t) {
          function o() {
            r.toggleOrientation(e), t();
          }
          return {
            set(t) {
              t.orientation && t.orientation !== e.orientation && o(),
                (t.fen ? a.anim : a.render)((e) => i.configure(e, t), e);
            },
            state: e,
            getFen: () => s.write(e.pieces),
            toggleOrientation: o,
            setPieces(t) {
              a.anim((e) => r.setPieces(e, t), e);
            },
            selectSquare(t, o) {
              t
                ? a.anim((e) => r.selectSquare(e, t, o), e)
                : e.selected && (r.unselect(e), e.dom.redraw());
            },
            move(t, o) {
              a.anim((e) => r.baseMove(e, t, o), e);
            },
            newPiece(t, o) {
              a.anim((e) => r.baseNewPiece(e, t, o), e);
            },
            playPremove() {
              if (e.premovable.current) {
                if (a.anim(r.playPremove, e)) return !0;
                e.dom.redraw();
              }
              return !1;
            },
            playPredrop(t) {
              if (e.predroppable.current) {
                const o = r.playPredrop(e, t);
                return e.dom.redraw(), o;
              }
              return !1;
            },
            cancelPremove() {
              a.render(r.unsetPremove, e);
            },
            cancelPredrop() {
              a.render(r.unsetPredrop, e);
            },
            cancelMove() {
              a.render((e) => {
                r.cancelMove(e), l.cancel(e);
              }, e);
            },
            stop() {
              a.render((e) => {
                r.stop(e), l.cancel(e);
              }, e);
            },
            setAutoShapes(t) {
              a.render((e) => (e.drawable.autoShapes = t), e);
            },
            setShapes(t) {
              a.render((e) => (e.drawable.shapes = t), e);
            },
            getKeyAtDomPos: (t) =>
              r.getKeyAtDomPos(t, r.whitePov(e), e.dom.bounds()),
            redrawAll: t,
            dragNewPiece(t, o, n) {
              l.dragNewPiece(e, t, o, n);
            },
            destroy() {
              r.stop(e), e.dom.unbind && e.dom.unbind(), (e.dom.destroyed = !0);
            },
          };
        });
    }),
    u = e(function (e, t) {
      Object.defineProperty(t, "__esModule", { value: !0 }),
        (t.defaults = void 0),
        (t.defaults = function () {
          return {
            pieces: s.read(s.initial),
            orientation: "white",
            turnColor: "white",
            coordinates: !0,
            autoCastle: !0,
            viewOnly: !1,
            disableContextMenu: !1,
            resizable: !0,
            addPieceZIndex: !1,
            pieceKey: !1,
            highlight: { lastMove: !0, check: !0 },
            animation: { enabled: !0, duration: 200 },
            movable: {
              free: !0,
              color: "both",
              showDests: !0,
              events: {},
              rookCastle: !0,
            },
            premovable: { enabled: !0, showDests: !0, castle: !0, events: {} },
            predroppable: { enabled: !1, events: {} },
            draggable: {
              enabled: !0,
              distance: 3,
              autoDistance: !0,
              showGhost: !0,
              deleteOnDropOff: !1,
            },
            dropmode: { active: !1 },
            selectable: { enabled: !0 },
            stats: { dragged: !("ontouchstart" in window) },
            events: {},
            drawable: {
              enabled: !0,
              visible: !0,
              eraseOnClick: !0,
              shapes: [],
              autoShapes: [],
              brushes: {
                green: {
                  key: "g",
                  color: "#15781B",
                  opacity: 1,
                  lineWidth: 10,
                },
                red: { key: "r", color: "#882020", opacity: 1, lineWidth: 10 },
                blue: { key: "b", color: "#003088", opacity: 1, lineWidth: 10 },
                yellow: {
                  key: "y",
                  color: "#e68f00",
                  opacity: 1,
                  lineWidth: 10,
                },
                paleBlue: {
                  key: "pb",
                  color: "#003088",
                  opacity: 0.4,
                  lineWidth: 15,
                },
                paleGreen: {
                  key: "pg",
                  color: "#15781B",
                  opacity: 0.4,
                  lineWidth: 15,
                },
                paleRed: {
                  key: "pr",
                  color: "#882020",
                  opacity: 0.4,
                  lineWidth: 15,
                },
                paleGrey: {
                  key: "pgr",
                  color: "#4a4a4a",
                  opacity: 0.35,
                  lineWidth: 15,
                },
              },
              pieces: {
                baseUrl: "https://lishogi1.org/assets/piece/cburnett/",
              },
              prevSvgHash: "",
            },
            hold: o.timer(),
          };
        });
    }),
    p = e(function (e, t) {
      function n(e) {
        return document.createElementNS("http://www.w3.org/2000/svg", e);
      }
      function r(
        { orig: e, dest: t, brush: o, piece: n, modifiers: r },
        i,
        a,
        c
      ) {
        return [
          c.width,
          c.height,
          a,
          e,
          t,
          o,
          t && (i.get(t) || 0) > 1,
          n && s(n),
          r && ((l = r), "" + (l.lineWidth || "")),
        ]
          .filter((e) => e)
          .join(",");
        var l;
      }
      function s(e) {
        return [e.color, e.role, e.scale].filter((e) => e).join(",");
      }
      function i(e, { shape: t, current: r, hash: s }, i, a, g) {
        let v;
        if (t.piece)
          v = (function (e, t, o, r) {
            const s = f(t, r),
              i = (r.width / 9) * (o.scale || 1),
              a =
                o.color[0] +
                ("knight" === o.role ? "n" : o.role[0]).toUpperCase();
            return c(n("image"), {
              className: `${o.role} ${o.color}`,
              x: s[0] - i / 2,
              y: s[1] - i / 2,
              width: i,
              height: i,
              href: e + a + ".svg",
            });
          })(
            e.drawable.pieces.baseUrl,
            l(o.key2pos(t.orig), e.orientation),
            t.piece,
            g
          );
        else {
          const s = l(o.key2pos(t.orig), e.orientation);
          if (t.dest) {
            let h = i[t.brush];
            t.modifiers && (h = d(h, t.modifiers)),
              (v = (function (e, t, o, r, s, i) {
                const a = (function (e, t) {
                    return ((t ? 20 : 10) / 512) * e.width;
                  })(i, s && !r),
                  l = f(t, i),
                  d = f(o, i),
                  g = d[0] - l[0],
                  v = d[1] - l[1],
                  h = Math.atan2(v, g),
                  m = Math.cos(h) * a,
                  b = Math.sin(h) * a;
                return c(n("line"), {
                  stroke: e.color,
                  "stroke-width": u(e, r, i),
                  "stroke-linecap": "round",
                  "marker-end": "url(#arrowhead-" + e.key + ")",
                  opacity: p(e, r),
                  x1: l[0],
                  y1: l[1],
                  x2: d[0] - m,
                  y2: d[1] - b,
                });
              })(
                h,
                s,
                l(o.key2pos(t.dest), e.orientation),
                r,
                (a.get(t.dest) || 0) > 1,
                g
              ));
          } else
            v = (function (e, t, o, r) {
              const s = f(t, r),
                i = (function (e) {
                  const t = e.width / 512;
                  return [3 * t, 4 * t];
                })(r),
                a = (r.width + r.height) / 36;
              return c(n("circle"), {
                stroke: e.color,
                "stroke-width": i[o ? 0 : 1],
                fill: "none",
                opacity: p(e, o),
                cx: s[0],
                cy: s[1],
                r: a - i[1] / 2,
              });
            })(i[t.brush], s, r, g);
        }
        return v.setAttribute("cgHash", s), v;
      }
      function a(e) {
        const t = c(n("marker"), {
          id: "arrowhead-" + e.key,
          orient: "auto",
          markerWidth: 4,
          markerHeight: 8,
          refX: 2.05,
          refY: 2.01,
        });
        return (
          t.appendChild(c(n("path"), { d: "M0,0 V4 L3,2 Z", fill: e.color })),
          t.setAttribute("cgKey", e.key),
          t
        );
      }
      function c(e, t) {
        for (const o in t) e.setAttribute(o, t[o]);
        return e;
      }
      function l(e, t) {
        return "white" === t ? e : [8 - e[0], 8 - e[1]];
      }
      function d(e, t) {
        return {
          color: e.color,
          opacity: Math.round(10 * e.opacity) / 10,
          lineWidth: Math.round(t.lineWidth || e.lineWidth),
          key: [e.key, t.lineWidth].filter((e) => e).join(""),
        };
      }
      function u(e, t, o) {
        return (((e.lineWidth || 10) * (t ? 0.85 : 1)) / 512) * o.width;
      }
      function p(e, t) {
        return (e.opacity || 1) * (t ? 0.9 : 1);
      }
      function f(e, t) {
        return [((e[0] + 0.5) * t.width) / 9, ((8.5 - e[1]) * t.height) / 9];
      }
      Object.defineProperty(t, "__esModule", { value: !0 }),
        (t.renderSvg = t.createElement = void 0),
        (t.createElement = n),
        (t.renderSvg = function (e, t) {
          const o = e.drawable,
            n = o.current,
            s = n && n.mouseSq ? n : void 0,
            c = new Map(),
            l = e.dom.bounds();
          for (const r of o.shapes.concat(o.autoShapes).concat(s ? [s] : []))
            r.dest && c.set(r.dest, (c.get(r.dest) || 0) + 1);
          const u = o.shapes
            .concat(o.autoShapes)
            .map((e) => ({ shape: e, current: !1, hash: r(e, c, !1, l) }));
          s && u.push({ shape: s, current: !0, hash: r(s, c, !0, l) });
          const p = u.map((e) => e.hash).join(";");
          if (p === e.drawable.prevSvgHash) return;
          e.drawable.prevSvgHash = p;
          const f = t.firstChild;
          !(function (e, t, o) {
            const n = new Map();
            let r;
            for (const a of t)
              a.shape.dest &&
                ((r = e.brushes[a.shape.brush]),
                a.shape.modifiers && (r = d(r, a.shape.modifiers)),
                n.set(r.key, r));
            const s = new Set();
            let i = o.firstChild;
            for (; i; ) s.add(i.getAttribute("cgKey")), (i = i.nextSibling);
            for (const [c, l] of n.entries()) s.has(c) || o.appendChild(a(l));
          })(o, u, f),
            (function (e, t, o, n, r, s) {
              const a = e.dom.bounds(),
                c = new Map(),
                l = [];
              for (const i of t) c.set(i.hash, !1);
              let d,
                u = s.nextSibling;
              for (; u; )
                (d = u.getAttribute("cgHash")),
                  c.has(d) ? c.set(d, !0) : l.push(u),
                  (u = u.nextSibling);
              for (const i of l) r.removeChild(i);
              for (const p of t)
                c.get(p.hash) || r.appendChild(i(e, p, o, n, a));
            })(e, u, o.brushes, c, t, f);
        });
    }),
    f = e(function (e, n) {
      function r(e, t) {
        const n = o.createEl("coords", t);
        let r;
        for (const s of e)
          (r = o.createEl("coord")), (r.textContent = s), n.appendChild(r);
        return n;
      }
      Object.defineProperty(n, "__esModule", { value: !0 }),
        (n.renderWrap = void 0),
        (n.renderWrap = function (e, n, s) {
          (e.innerHTML = ""), e.classList.add("cg-wrap");
          for (const o of t.colors)
            e.classList.toggle("orientation-" + o, n.orientation === o);
          e.classList.toggle("manipulable", !n.viewOnly);
          const i = o.createEl("cg-helper");
          e.appendChild(i);
          const a = o.createEl("cg-container");
          i.appendChild(a);
          const c = o.createEl("cg-board");
          let l, d;
          if (
            (a.appendChild(c),
            n.drawable.visible &&
              !s &&
              ((l = p.createElement("svg")),
              l.appendChild(p.createElement("defs")),
              a.appendChild(l)),
            n.coordinates)
          ) {
            const e = "black" === n.orientation ? " black" : "";
            a.appendChild(
              r(["i", "h", "g", "f", "e", "d", "c", "b", "a"], "ranks" + e)
            ),
              a.appendChild(
                r(["9", "8", "7", "6", "5", "4", "3", "2", "1"], "files" + e)
              );
          }
          return (
            n.draggable.showGhost &&
              !s &&
              ((d = o.createEl("piece", "ghost")),
              o.setVisible(d, !1),
              a.appendChild(d)),
            { board: c, container: a, ghost: d, svg: l }
          );
        });
    }),
    g = e(function (e, t) {
      Object.defineProperty(t, "__esModule", { value: !0 }),
        (t.drop = t.cancelDropMode = t.setDropMode = void 0),
        (t.setDropMode = function (e, t) {
          (e.dropmode = { active: !0, piece: t }), l.cancel(e);
        }),
        (t.cancelDropMode = function (e) {
          e.dropmode = { active: !1 };
        }),
        (t.drop = function (e, t) {
          if (!e.dropmode.active) return;
          r.unsetPremove(e), r.unsetPredrop(e);
          const n = e.dropmode.piece;
          if (n) {
            e.pieces.set("a0", n);
            const s = o.eventPosition(t),
              i = s && r.getKeyAtDomPos(s, r.whitePov(e), e.dom.bounds());
            i && r.dropNewPiece(e, "a0", i);
          }
          e.dom.redraw();
        });
    }),
    v = e(function (e, t) {
      function n(e, t, o, n) {
        return (
          e.addEventListener(t, o, n), () => e.removeEventListener(t, o, n)
        );
      }
      function r(e, t, o) {
        return (n) => {
          e.drawable.current
            ? e.drawable.enabled && o(e, n)
            : e.viewOnly || t(e, n);
        };
      }
      Object.defineProperty(t, "__esModule", { value: !0 }),
        (t.bindDocument = t.bindBoard = void 0),
        (t.bindBoard = function (e, t) {
          const n = e.dom.elements.board;
          if (!e.dom.relative && e.resizable && "ResizeObserver" in window) {
            new window.ResizeObserver(t).observe(n);
          }
          if (e.viewOnly) return;
          const r = (function (e) {
            return (t) => {
              e.draggable.current
                ? l.cancel(e)
                : e.drawable.current
                ? c.cancel(e)
                : t.shiftKey || o.isRightButton(t)
                ? e.drawable.enabled && c.start(e, t)
                : e.viewOnly ||
                  (e.dropmode.active ? g.drop(e, t) : l.start(e, t));
            };
          })(e);
          n.addEventListener("touchstart", r, { passive: !1 }),
            n.addEventListener("mousedown", r, { passive: !1 }),
            (e.disableContextMenu || e.drawable.enabled) &&
              n.addEventListener("contextmenu", (e) => e.preventDefault());
        }),
        (t.bindDocument = function (e, t) {
          const o = [];
          if (
            (e.dom.relative ||
              !e.resizable ||
              "ResizeObserver" in window ||
              o.push(n(document.body, "shogiground.resize", t)),
            !e.viewOnly)
          ) {
            const t = r(e, l.move, c.move),
              s = r(e, l.end, c.end);
            for (const e of ["touchmove", "mousemove"])
              o.push(n(document, e, t));
            for (const e of ["touchend", "mouseup"]) o.push(n(document, e, s));
            const i = () => e.dom.bounds.clear();
            o.push(n(document, "scroll", i, { capture: !0, passive: !0 })),
              o.push(n(window, "resize", i, { passive: !0 }));
          }
          return () => o.forEach((e) => e());
        });
    }),
    h = e(function (e, t) {
      Object.defineProperty(t, "__esModule", { value: !0 }),
        (t.updateBounds = t.render = void 0);
      const n = o;
      function s(e) {
        return "PIECE" === e.tagName;
      }
      function i(e) {
        return "SQUARE" === e.tagName;
      }
      function a(e, t) {
        for (const o of t) e.dom.elements.board.removeChild(o);
      }
      function c(e, t) {
        let o = 2 + 9 * e[1] + (8 - e[0]);
        return t && (o = 84 - o), o + "";
      }
      function l(e) {
        return `${e.color} ${e.role}`;
      }
      function d(e, t, o) {
        const n = e.get(t);
        n ? e.set(t, `${n} ${o}`) : e.set(t, o);
      }
      function u(e, t, o) {
        const n = e.get(t);
        n ? n.push(o) : e.set(t, [o]);
      }
      (t.render = function (e) {
        const t = r.whitePov(e),
          p = e.dom.relative
            ? n.posToTranslateRel
            : n.posToTranslateAbs(e.dom.bounds()),
          f = e.dom.relative ? n.translateRel : n.translateAbs,
          g = e.dom.elements.board,
          v = e.pieces,
          h = e.animation.current,
          m = h ? h.plan.anims : new Map(),
          b = h ? h.plan.fadings : new Map(),
          w = e.draggable.current,
          y = (function (e) {
            var t;
            const o = new Map();
            if (e.lastMove && e.highlight.lastMove)
              for (const r of e.lastMove) d(o, r, "last-move");
            e.check && e.highlight.check && d(o, e.check, "check");
            if (
              e.selected &&
              (d(o, e.selected, "selected"), e.movable.showDests)
            ) {
              const n =
                null === (t = e.movable.dests) || void 0 === t
                  ? void 0
                  : t.get(e.selected);
              if (n)
                for (const t of n)
                  d(o, t, "move-dest" + (e.pieces.has(t) ? " oc" : ""));
              const r = e.premovable.dests;
              if (r)
                for (const t of r)
                  d(o, t, "premove-dest" + (e.pieces.has(t) ? " oc" : ""));
            }
            const n = e.premovable.current;
            if (n) for (const r of n) d(o, r, "current-premove");
            else
              e.predroppable.current &&
                d(o, e.predroppable.current.key, "current-premove");
            return o;
          })(e),
          P = new Set(),
          k = new Set(),
          M = new Map(),
          C = new Map();
        let S, A, K, O, D, _, N, E, x, L;
        for (A = g.firstChild; A; ) {
          if (((S = A.cgKey), s(A)))
            if (
              ((K = v.get(S)),
              (D = m.get(S)),
              (_ = b.get(S)),
              (O = A.cgPiece),
              !A.cgDragging ||
                (w && w.orig === S) ||
                (A.classList.remove("dragging"),
                f(A, p(o.key2pos(S), t)),
                (A.cgDragging = !1)),
              !_ &&
                A.cgFading &&
                ((A.cgFading = !1), A.classList.remove("fading")),
              K)
            ) {
              if (D && A.cgAnimating && O === l(K)) {
                const e = o.key2pos(S);
                (e[0] += D[2]),
                  (e[1] += D[3]),
                  A.classList.add("anim"),
                  f(A, p(e, t));
              } else
                A.cgAnimating &&
                  ((A.cgAnimating = !1),
                  A.classList.remove("anim"),
                  f(A, p(o.key2pos(S), t)),
                  e.addPieceZIndex && (A.style.zIndex = c(o.key2pos(S), t)));
              O !== l(K) || (_ && A.cgFading)
                ? _ && O === l(_)
                  ? (A.classList.add("fading"), (A.cgFading = !0))
                  : u(M, O, A)
                : P.add(S);
            } else u(M, O, A);
          else if (i(A)) {
            const e = A.className;
            y.get(S) === e ? k.add(S) : u(C, e, A);
          }
          A = A.nextSibling;
        }
        for (const [n, r] of y)
          if (!k.has(n)) {
            (x = C.get(r)), (L = x && x.pop());
            const e = p(o.key2pos(n), t);
            if (L) (L.cgKey = n), f(L, e);
            else {
              const t = o.createEl("square", r);
              (t.cgKey = n), f(t, e), g.insertBefore(t, g.firstChild);
            }
          }
        for (const [n, r] of v)
          if (((D = m.get(n)), !P.has(n)))
            if (((N = M.get(l(r))), (E = N && N.pop()), E)) {
              (E.cgKey = n),
                E.cgFading && (E.classList.remove("fading"), (E.cgFading = !1));
              const r = o.key2pos(n);
              e.addPieceZIndex && (E.style.zIndex = c(r, t)),
                D &&
                  ((E.cgAnimating = !0),
                  E.classList.add("anim"),
                  (r[0] += D[2]),
                  (r[1] += D[3])),
                f(E, p(r, t));
            } else {
              const s = l(r),
                i = o.createEl("piece", s),
                a = o.key2pos(n);
              (i.cgPiece = s),
                (i.cgKey = n),
                D && ((i.cgAnimating = !0), (a[0] += D[2]), (a[1] += D[3])),
                f(i, p(a, t)),
                e.addPieceZIndex && (i.style.zIndex = c(a, t)),
                g.appendChild(i);
            }
        for (const o of M.values()) a(e, o);
        for (const o of C.values()) a(e, o);
      }),
        (t.updateBounds = function (e) {
          if (e.dom.relative) return;
          const t = r.whitePov(e),
            a = n.posToTranslateAbs(e.dom.bounds());
          let c = e.dom.elements.board.firstChild;
          for (; c; )
            ((s(c) && !c.cgAnimating) || i(c)) &&
              n.translateAbs(c, a(o.key2pos(c.cgKey), t)),
              (c = c.nextSibling);
        });
    });
  return e(function (e, t) {
    function n(e) {
      let t = !1;
      return () => {
        t ||
          ((t = !0),
          requestAnimationFrame(() => {
            e(), (t = !1);
          }));
      };
    }
    Object.defineProperty(t, "__esModule", { value: !0 }),
      (t.Shogiground = void 0),
      (t.Shogiground = function (e, t) {
        const r = u.defaults();
        function s() {
          const t = r.dom && r.dom.unbind,
            s = r.viewOnly && !r.drawable.visible,
            i = f.renderWrap(e, r, s),
            a = o.memo(() => i.board.getBoundingClientRect()),
            c = (e) => {
              h.render(r), !e && i.svg && p.renderSvg(r, i.svg);
            },
            l = () => {
              a.clear(), h.updateBounds(r), i.svg && p.renderSvg(r, i.svg);
            };
          (r.dom = {
            elements: i,
            bounds: a,
            redraw: n(c),
            redrawNow: c,
            unbind: t,
            relative: s,
          }),
            (r.drawable.prevSvgHash = ""),
            c(!1),
            v.bindBoard(r, l),
            t || (r.dom.unbind = v.bindDocument(r, l)),
            r.events.insert && r.events.insert(i);
        }
        return i.configure(r, t || {}), s(), d.start(r, s);
      });
  }).Shogiground;
})();
